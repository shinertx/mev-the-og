 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/README.md b/README.md
index 9c26e0c..c88c026 100644
--- a/README.md
+++ b/README.md
@@ -6,25 +6,37 @@ Build and operate the world’s most aggressive, adaptive, AI/quant-driven crypt
 ## Quickstart
 
 1. Install dependencies:  
    `pip install -r requirements.txt`
 
 2. Fill in `config.yaml` (see `.env.example` for env vars).
 
 3. Run any alpha module:  
    - `python main.py --mode test --alpha cross_chain`
    - `python main.py --mode test --alpha mev_share`
    - (or try any in `src/alpha/`)
 
 4. Logs are in `logs/mev_og.log`.
 
 5. See the dashboard:  
    `python main.py --dashboard`
 
 ## Structure
 
 - `src/alpha/` – All advanced MEV modules
 - `src/` – Core bot, risk, kill switch, utils, dashboard, notifier
 - `tests/` – Full test suite
 - `logs/` – Log output
 - `Dockerfile` – Run anywhere
 - `run.sh` – Example launch script
+
+## Disaster Recovery
+Refer to `docs/DRP.md` for the full snapshot and restore process. Before any
+upgrade or secret change, run:
+```
+python scripts/snapshot.py
+```
+To rollback to the last known good state run:
+```
+python scripts/restore.py
+```
+Snapshots and restores are logged in `snapshots/snapshot.log`.
diff --git a/docs/DRP.md b/docs/DRP.md
new file mode 100644
index 0000000..8ef6d7f
--- /dev/null
+++ b/docs/DRP.md
@@ -0,0 +1,22 @@
+# Disaster Recovery Process (DRP)
+
+The DRP outlines how to capture snapshots before risky changes and how to restore the bot in case of failure.
+
+## Snapshot workflow
+1. Run `python scripts/snapshot.py` before any upgrade, config or secret change.
+2. A timestamped folder will be created under `snapshots/` containing:
+   - `commit.txt` – current git commit hash
+   - `config.yaml` – current config
+   - `env_hash.txt` – SHA256 hash of `.env` secrets
+   - `logs.zip` – archived logs
+   - `health.txt` – result of basic health check
+3. Each snapshot is logged in `snapshots/snapshot.log` with UTC timestamp.
+
+## Restore workflow
+1. If the bot halts or upgrade fails, run `python scripts/restore.py`.
+2. The script resets git to the last snapshot commit, restores `config.yaml`,
+   checks the `.env` hash and prints a health status.
+3. Restore events are also appended to `snapshots/snapshot.log`.
+4. Once health is `healthy`, trading can resume.
+
+Use these commands manually or incorporate them into CI/CD before deploying new versions.
diff --git a/scripts/__init__.py b/scripts/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/scripts/restore.py b/scripts/restore.py
new file mode 100644
index 0000000..5b9b722
--- /dev/null
+++ b/scripts/restore.py
@@ -0,0 +1,62 @@
+import os
+import shutil
+import subprocess
+from glob import glob
+
+SNAP_DIR = "snapshots"
+LOG_FILE = os.path.join(SNAP_DIR, "snapshot.log")
+
+
+def latest_snapshot():
+    snaps = sorted([d for d in glob(os.path.join(SNAP_DIR, "*")) if os.path.isdir(d)])
+    return snaps[-1] if snaps else None
+
+
+def restore_snapshot(folder):
+    commit_file = os.path.join(folder, "commit.txt")
+    cfg_file = os.path.join(folder, "config.yaml")
+    env_hash_file = os.path.join(folder, "env_hash.txt")
+
+    if os.path.exists(commit_file):
+        commit = open(commit_file).read().strip()
+        try:
+            subprocess.check_call(["git", "reset", "--hard", commit])
+        except Exception:
+            print("Failed to reset git commit")
+
+    if os.path.exists(cfg_file):
+        shutil.copy(cfg_file, "config.yaml")
+
+    if os.path.exists(env_hash_file) and os.path.exists(".env"):
+        with open(env_hash_file) as f:
+            expected = f.read().strip()
+        import hashlib
+        with open(".env", "rb") as f:
+            current = hashlib.sha256(f.read()).hexdigest()
+        if current != expected:
+            print("[WARN] .env hash mismatch during restore")
+
+    # post-restore health check
+    health = "unknown"
+    try:
+        subprocess.check_call(["python", "-m", "py_compile", "main.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
+        health = "healthy"
+    except Exception:
+        health = "unhealthy"
+
+    ts = os.path.basename(folder)
+    with open(LOG_FILE, "a") as log:
+        log.write(f"{ts} RESTORE {folder}\n")
+    print(f"Restored snapshot {folder} - health: {health}")
+
+
+def main():
+    folder = latest_snapshot()
+    if not folder:
+        print("No snapshots found")
+        return
+    restore_snapshot(folder)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/scripts/snapshot.py b/scripts/snapshot.py
new file mode 100644
index 0000000..5f4450d
--- /dev/null
+++ b/scripts/snapshot.py
@@ -0,0 +1,63 @@
+import os
+import shutil
+import hashlib
+import datetime
+import subprocess
+
+SNAP_DIR = "snapshots"
+LOG_FILE = os.path.join(SNAP_DIR, "snapshot.log")
+
+def ensure_dirs():
+    os.makedirs(SNAP_DIR, exist_ok=True)
+
+
+def get_commit_hash():
+    try:
+        return subprocess.check_output(["git", "rev-parse", "HEAD"]).decode().strip()
+    except Exception:
+        return "unknown"
+
+
+def health_check():
+    # Simple health check placeholder
+    try:
+        subprocess.check_call(["python", "-m", "py_compile", "main.py"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
+        return "healthy"
+    except Exception:
+        return "unhealthy"
+
+
+def create_snapshot():
+    ensure_dirs()
+    ts = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
+    folder = os.path.join(SNAP_DIR, ts)
+    os.makedirs(folder, exist_ok=True)
+
+    commit = get_commit_hash()
+    with open(os.path.join(folder, "commit.txt"), "w") as f:
+        f.write(commit + "\n")
+
+    if os.path.exists("config.yaml"):
+        shutil.copy("config.yaml", os.path.join(folder, "config.yaml"))
+
+    env_hash = "missing"
+    if os.path.exists(".env"):
+        with open(".env", "rb") as f:
+            env_hash = hashlib.sha256(f.read()).hexdigest()
+    with open(os.path.join(folder, "env_hash.txt"), "w") as f:
+        f.write(env_hash + "\n")
+
+    if os.path.isdir("logs"):
+        shutil.make_archive(os.path.join(folder, "logs"), "zip", "logs")
+
+    health = health_check()
+    with open(os.path.join(folder, "health.txt"), "w") as f:
+        f.write(health + "\n")
+
+    with open(LOG_FILE, "a") as log:
+        log.write(f"{ts} SNAPSHOT {folder}\n")
+    print(f"Snapshot created at {folder}")
+
+
+if __name__ == "__main__":
+    create_snapshot()
diff --git a/tests/test_drp_workflow.py b/tests/test_drp_workflow.py
new file mode 100644
index 0000000..0a2947e
--- /dev/null
+++ b/tests/test_drp_workflow.py
@@ -0,0 +1,30 @@
+import os
+import subprocess
+
+from scripts import snapshot as snapshot_mod
+from scripts import restore as restore_mod
+
+
+def init_repo(path):
+    os.chdir(path)
+    subprocess.run(["git", "init"], check=True, stdout=subprocess.DEVNULL)
+    (path / "config.yaml").write_text("val: 1")
+    subprocess.run(["git", "add", "config.yaml"], check=True)
+    subprocess.run(["git", "commit", "-m", "init"], check=True, stdout=subprocess.DEVNULL)
+    os.makedirs(path / "logs")
+    (path / "logs" / "mev_og.log").write_text("log")
+
+
+def test_snapshot_and_restore(tmp_path, monkeypatch):
+    init_repo(tmp_path)
+    monkeypatch.chdir(tmp_path)
+    monkeypatch.setattr(snapshot_mod, "SNAP_DIR", str(tmp_path / "snaps"))
+    monkeypatch.setattr(restore_mod, "SNAP_DIR", str(tmp_path / "snaps"))
+
+    snapshot_mod.create_snapshot()
+    snap = restore_mod.latest_snapshot()
+    assert snap is not None
+    # modify config
+    (tmp_path / "config.yaml").write_text("val: 2")
+    restore_mod.restore_snapshot(snap)
+    assert (tmp_path / "config.yaml").read_text() == "val: 1"
 
EOF
)